#模块那些事儿 Python 2.7
结合《Python参考手册》以及《Python基础教程》


模块与import语句

#spam.py
a = 37
def foo():
    print "I'm foo and a is %s" %a
def bar():
    print "I'm bar and I'm calling foo"
    foo()
class Spam(object):
    def grok(self):
        print "I'm Spam.grok'"
        
以模块形式首次用import加载这段代码的时候，有3件事要发生
1.创建新的命名空间，将spam.py中定义的所有对象放置其中，在模块中定义的函数和方法在使用global语句时将访问该命名空间。
2.在新创建的命名空间中执行模块中的代码
3.在调用函数中创建名称来引用模块命名空间，这个名称==模块的名称，如下调用

import spam          #加载并执行spam
x = spam.a           #访问spam模块中名为a的成员
spam.foo()           #调用spam模块中名为foo的函数   
s = spam.Spam()      #创建spam.Spam()的一个实例，特别注意引用类的方式
s.grok()

导入多个模块
import socket，os，re

更改已导入模块的名称
import spam as sp
sp.foo()
改名称的好处是对于编写可扩展的代码很有用。例如，需要导入的2个模块中都有一个read()的函数，在import之前需要if...elif 的判断，
导入模块时将这2个模块都命名为reader，那么调用函数时只需要reader.read()即可。

只导入一次的原因是，如果有2个模块互相导入，这时候导入就成了无限循环。


从模块中导入选定符号

from语句用于将模块中的具体定义加载到当前命名空间中。from语句相当于import，但它不会创建一个名称来引用新创建的模块命名空间
而是将对模块中定义的对象的引用放到当前命名空间中：

from spam import foo        #导入spam并将foo放在当前命名空间中
foo()                       #调用spam.foo()
spam.foo()                  #NameError:spam

from 亦可导入多个对象名称列表，若对象太长，也可

from spam import （foo,
                   bar,
                   Spam)
                         
                     
from也支持更改已导入对象的名称
from spam import Spam as Sp
s = Sp()

from spam import *  #将所有定义（不以下划线开头的定义）加载到当前命名空间，并且该语句只能在模块最顶层使用
那么如何知道到底有哪些定义被导入了呢？
__all__ 定义了模块的公有接口，它告诉解释器：从模块导入所有名字代表什么含义，也就是哪些定义会被导入。__all__起到了一个过滤器的作用，
因为模块中可能含有一大推其它程序不需要或不想要的变量，函数和类，__all__会将它们过滤掉。

使用from导入，导入的定义不会更改该定义所在的作用域,忠于原模块，属于原模块的命名空间
from spam import foo
a = 42
foo()               #"I'm foo and a is 37"

from spam import bar
def foo():
    print "I'm a different foo"
bar()               #当bar调用foo()时，它将调用spam.foo(),而不是上面的foo()

from spam import a, foo         #导入全局变量
a = 42                          #修改该变量
foo()                           #"I'm foo and a is 37"
print  a                        #"42"
 
Python中的变量赋值不是一种存储操作，上例中对a的赋值不会将新值存储在a中并覆盖以前的值，
而是将创建包含值42得新对象，并用名称a来引用它。此时a不在绑定到导入模块中的值，而是绑定到其它对象。
                   
                   
在模块中增加测试代码，（即将模块以主程序的形式执行）
关键在于：如何“告知”模块本身是作为程序运行 or 导入其它。
在解释器中，变量__name__的值为'__main__'。而在导入的模块中，这个值就被设定为模块的名字spam。
所以用if __name__=='__main__': test()
test()包含了测试代码，重新定义测试函数test()的好处是更加灵活，在模块被导入后也可以执行测试工作：spam.test()


让你的模块能够被找到
加载模块时，解释器搜索sys.path中的目录列表，并且按照列表顺序搜索
['',   #表示当前正在使用的目录
'/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip',
'/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7', 
'/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin', 
'/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac', 
'/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages', 
'/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk', 
'/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old', 
'/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload', 
'/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages']
可以在搜索列表中添加.egg文件，.egg文件是由setuptools库创建的包。在安装第三方Python库和扩展时会碰到的一种常见格式。
.egg文件实际上只是添加了额外的元数据（如版本号，依赖关系等等）的.zip文件。

import加载的模块可分为4个类别：
1.使用Python编写的代码(.py文件)
2.包含一组模块的包
3.已被编译为共享库或DLL的C或C++扩展
4.使用C编写并链接到Python解释器的内置模块


                 
                   
