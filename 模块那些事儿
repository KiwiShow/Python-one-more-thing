#模块那些事儿 Python 2.7
结合《Python参考手册》以及《Python基础教程》


模块与import语句

#spam.py
a = 37
def foo():
    print "I'm foo and a is %s" %a
def bar():
    print "I'm bar and I'm calling foo"
    foo()
class Spam(object):
    def grok(self):
        print "I'm Spam.grok'"
        
以模块形式首次用import加载这段代码的时候，有3件事要发生
1.创建新的命名空间，将spam.py中定义的所有对象放置其中，在模块中定义的函数和方法在使用global语句时将访问该命名空间。
2.在新创建的命名空间中执行模块中的代码
3.在调用函数中创建名称来引用模块命名空间，这个名称==模块的名称，如下调用

import spam          #加载并执行spam
x = spam.a           #访问spam模块中名为a的成员
spam.foo()           #调用spam模块中名为foo的函数   
s = spam.Spam()      #创建spam.Spam()的一个实例，特别注意引用类的方式
s.grok()

导入多个模块
import socket，os，re

更改已导入模块的名称
import spam as sp
sp.foo()
改名称的好处是对于编写可扩展的代码很有用。例如，需要导入的2个模块中都有一个read()的函数，在import之前需要if...elif 的判断，
导入模块时将这2个模块都命名为reader，那么调用函数时只需要reader.read()即可。

只导入一次的原因是，如果有2个模块互相导入，这时候导入就成了无限循环。


从模块中导入选定符号

from语句用于将模块中的具体定义加载到当前命名空间中。from语句相当于import，但它不会创建一个名称来引用新创建的模块命名空间
而是将对模块中定义的对象的引用放到当前命名空间中：

from spam import foo        #导入spam并将foo放在当前命名空间中
foo()                       #调用spam.foo()
spam.foo()                  #NameError:spam

from 亦可导入多个对象名称列表，若对象太长，也可

from spam import （foo,
                   bar,
                   Spam)
                         
                     
from也支持更改已导入对象的名称
from spam import Spam as Sp
s = Sp()

from spam import *  #将所有定义（不以下划线开头的定义）加载到当前命名空间，并且该语句只能在模块最顶层使用
那么如何知道到底有哪些定义被导入了呢？
__all__ 定义了模块的公有接口，它告诉解释器：从模块导入所有名字代表什么含义，也就是哪些定义会被导入。__all__起到了一个过滤器的作用，
因为模块中可能含有一大推其它程序不需要或不想要的变量，函数和类，__all__会将它们过滤掉。

使用from导入，导入的定义不会更改该定义所在的作用域,忠于原模块，属于原模块的命名空间
from spam import foo
a = 42
foo()               #"I'm foo and a is 37"

from spam import bar
def foo():
    print "I'm a different foo"
bar()               #当bar调用foo()时，它将调用spam.foo(),而不是上面的foo()

from spam import a, foo         #导入全局变量
a = 42                          #修改该变量
foo()                           #"I'm foo and a is 37"
print  a                        #"42"
 
Python中的变量赋值不是一种存储操作，上例中对a的赋值不会将新值存储在a中并覆盖以前的值，
而是将创建包含值42得新对象，并用名称a来引用它。此时a不在绑定到导入模块中的值，而是绑定到其它对象。
                   
